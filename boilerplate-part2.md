# Building Smart Contract Project Boilerplate (Part 2)

âš  make sure you already followed through [Part 1](./boilerplate.md), which setup a nice boilerplate with rich set of plugins installed, before moving on.ï¸

While "part 1" has built up some basic "skeleton", this "part 2" will emphasize on introducing more "muscle" to our project such as essential list of `chai matchers` from `waffle`, and Mocking capabilities via `smock`.

Even though all tools introduced here are technically optional (you can already run away as "bag of bones"),
we would strongly recommend you to utilize these tools because they would accelerate your development especially when your contracts become more complex and harder to test comprehensively.

ðŸ‘ We know these new tools and setups can be overwhelming, just so you know, you are already doing a great job! Keep up the effort and you are on your way to become a powerful smart contract developers!

- [Testing with `waffle`](#testing-with-waffle)
- [Mocking with `smock`](#mocking-with-smock)
- [Special testing: Moving in time](#special-testing-moving-in-time)
- [Special testing: Mainnet Forking](#special-testing-mainnet-forking)

## Testing with `waffle`

[`waffle`](https://ethereum-waffle.readthedocs.io/en/latest/index.html) is a testing library for smart contracts.
While it provides features from contract compilation to contract testing, we will mostly using 2 features from `waffle`:

- its sweet set of [`chai` matchers](https://ethereum-waffle.readthedocs.io/en/latest/matchers.html) for easy assertions.
- its [testing fixtures](https://ethereum-waffle.readthedocs.io/en/latest/fixtures.html) to save repetitive pre-state setup for tests to speed up execution.

Note that using `hardhat`'s own compilation, `ethers`'s contract factory deployment flow (explained later), and `typechain`'s contract types.
Astute readers might wonder an abstract question: "why could one compile using `hardhat`, but test with `waffle`?" -- the answer is the contract artifacts (under `build/artifacts`) generated by both tools are compatible.

Now let's setup our `hardhat` project with `waffle` (also check out [official doc](https://hardhat.org/guides/waffle-testing.html) if you want, or you could just follow our write-up).

> Since our "part 1" boilerplate is already built on a sample hardhat project which by default installed all dependencies of `waffle`, we can directly jump to writing tests. In case you missed it, you can install them with `yarn add -D @nomiclabs/hardhat-waffle ethereum-waffle chai @nomiclabs/hardhat-ethers ethers`.

1. To demonstrate a few of waffles' testing features, let's modify our `contracts/Greeter.sol`:

   ```solidity
   contract Greeter {
     // add a new event:
     event GreetingUpdated(string _new, address setter, uint256 amount);

     // update `setGreeting` as follows:
     function setGreeting(string memory _greeting) public payable {
       console.log("Changing greeting from", greeting, "to", _greeting);
       require(msg.value >= 1 ether, "minimal donation is 1 ether");
       greeting = _greeting;
       emit GreetingUpdated(_greeting, msg.sender, msg.value);
     }
   }

   ```

2. Jump to `test/greeter.spec.ts`, change it to the following:

   ```typescript
   import chai, { expect } from "chai";
   import { ethers, waffle } from "hardhat";
   import { Greeter } from "@typechained";
   const { solidity } = waffle;
   import GreeterABI from "../build/artifacts/contracts/Greeter.sol/Greeter.json";

   chai.use(solidity);

   describe("Greeter", () => {
     let greeter: Greeter;
     // this is the same list as `ethers.getSigners()`
     let [_, bob] = waffle.provider.getWallets();
     const initGreeting = "Hello, world!";

     const fixture = async () => {
       return (await waffle.deployContract(bob, GreeterABI, [
         initGreeting,
       ])) as Greeter;
     };

     beforeEach(async () => {
       greeter = await waffle.loadFixture(fixture);
     });

     it("Initalize with correct default greeting", async () => {
       expect(await greeter.greet()).to.equal(initGreeting);
     });

     describe("#setGreeting", () => {
       const newGreeting = "Bonjour!";

       it("should revert with insufficent donation", async () => {
         // this will send from alice (or first wallet) by default
         await expect(
           greeter.setGreeting(newGreeting, {
             value: ethers.utils.parseEther("0.9"),
           })
         ).to.be.reverted;
       });

       it("should update the greeting with sufficient donation", async () => {
         const donationInWei = ethers.utils.parseEther("2");
         // reconnect contract with a different signer before calling if you want to send from a different wallet.
         await expect(
           greeter.connect(bob).setGreeting(newGreeting, {
             value: donationInWei,
           })
         )
           // the following line is temporarily broken after London hardfork
           // .to.changeEtherBalances(greeter, [bob, greeter], [-donationInWei, donationInWei])
           .to.emit(greeter, "GreetingUpdated")
           .withArgs(newGreeting, bob.address, donationInWei);

         expect(await greeter.greet()).to.equal(newGreeting);
       });
     });
   });
   ```

   Then run `yarn test`, you should see all 3 tests passing.

Now, let's dive deeper into the test file.

- Since we are using `hardhat-waffle` plugin instead of a standalone `waffle` project, we use `import { waffle } from 'hardhat'` then `const { xxx } = waffle`, instead of directly from `import { xxx } from 'ethereum-waffle'`.
  Basically, the plugin re-export waffle with more integration setups through `hardhat.waffle` object, as explained [here](https://hardhat.org/guides/waffle-testing.html#adapting-the-tests).
- `chai.use(solidity)` enrich the default set of `chai matchers` (for general software) with a list of super helpful [contract-specific matchers](https://ethereum-waffle.readthedocs.io/en/latest/matchers.html).
  We will see a few example usages below.
- We use `waffle.provider.getWallets()` to get the list of wallets to deploy and send transactions later in the tests. The account list is the same as `ethers.getSigners()` result or `yarn hardhat accounts` output.
- Next we utilize the second important feature of `waffle` called [**fixtures**](https://ethereum-waffle.readthedocs.io/en/latest/fixtures.html). Please follow the link to read more. We usually use fixtures to avoid repetitive contract deployment for each test cases, instead we load from fixtures -- think of it as snapshot machine for contracts.
- For contracts deployment in tests, there are two ways:

  ```typescript
  import { Greeter } from "@typechained";
  import { ethers, waffle } from "hardhat";

  // either using `ethers`'s `ContractFactory`
  const factory = await ethers.getContractFactory("Greeter");
  const greeter = (await factory.deploy("my constructor param")) as Greeter;

  // or using `waffle`'s `deployContract`
  import GreeterABI from "../build/artifacts/contracts/Greeter.sol/Greeter.json";
  const greeter = (await waffle.deployContract(bob, GreeterABI, [
    "my constructor param",
  ])) as Greeter;
  ```

- As for the `mocha` test runner's execution order among nested `before()` and `beforeEach()`, please refer to [this StackOverflow question](https://stackoverflow.com/questions/21418580/what-is-the-difference-between-before-and-beforeeach#21419208)
- In the first test, we saw a standard `chai` matcher: `.to.equal()`.
- In the second test, we saw a matcher provided by `waffle.solidity` that we ask `chai.use(solidity)` before: [`.to.be.reverted`](https://ethereum-waffle.readthedocs.io/en/latest/matchers.html#revert).
- In the third test, we saw another matcher `to.emit().withArgs()` to test correct event emission. Note that you can "chain" assersions together like `expect().to.equal().to.emit()`.

ðŸŽ‰ Now you have basics of waffle testing under your belt!

## Mocking with `smock`

## Special testing: Moving in time

Suppose you built a blind auction contract with a "commit" phase and a "reveal" phase, each elapse for certain period of time (measured in block number).
It's a common testing requirement to simulate fast-forwarding to a future timestamp and check contract states.

While you can manually call `ethers.network.provider.request({ method: 'evm_mine' })` or `evm_setNextBlockTimestamp`, we curate a list of utility functions to help you navigate in "time".

Please check out [`test/utils/evm.ts`](./packages/smart-contracts-boilerplate-sample/test/utils/evm.ts), and the following helper functions:

```typescript
export declare const getBlockNumber: () => Promise<number>;
export declare const advanceTimeAndBlock: (time: number) => Promise<void>;
export declare const advanceToTimeAndBlock: (time: number) => Promise<void>;
export declare const advanceTime: (time: number) => Promise<void>;
export declare const advanceToTime: (time: number) => Promise<void>;
export declare const advanceBlock: () => Promise<void>;
export declare const reset: (hre: HardhatRuntimeEnvironment) => Promise<void>;
declare class SnapshotManager {
  snapshots: {
    [id: string]: string;
  };
  take(): Promise<string>;
  revert(id: string): Promise<void>;
  private takeSnapshot;
  private revertSnapshot;
}
export declare const snapshot: SnapshotManager;
```

## Special testing: Mainnet Forking

One of the attractive features of `hardhat` is its support for ["mainnet forking"](https://hardhat.org/hardhat-network/guides/mainnet-forking.html).

> You can start an instance of Hardhat Network that forks mainnet. This means that it will simulate having the same state as mainnet, but it will work as a local development network. That way you can interact with deployed protocols and test complex interactions locally.

The toy example, we try to sync with the state of DAI stable coin contract on the mainnet, and simulate a transfer from `vitalik.eth` to a stranger account.
Note `vitalik.eth`'s DAI balance is accurately synced, and yet our simulated transfer didn't happen in actual history -- thus the name "forking".

1. Specify in `hardhat.config.ts`:

   ```typescript
   const config: HardhatUserConfig = {
     networks: {
       //..
       hardhat: {
         //...
         forking: {
           url: nodeUrl("mainnet"),
           blockNumber: 13000000, // (Aug-10-2021 09:53:39 PM +UTC) post London fork
         },
       },
     },
   };
   ```

2. To get the TypeChain artifacts of DAI contract, we create a dummy `contract/Dai.sol`:

   ```solidity
   // SPDX-License-Identifier: MIT
   pragma solidity ^0.8.0;
   import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

   contract DaiMock is ERC20("Dai Stablecoin", "DAI") {}

   ```

   We further copy paste the entire [`test/utils/` folder](./packages/smart-contracts-boilerplate-sample/test/utils) to your project.

   Then we write our `test/dai.test.ts`, the test is quite self-explanatory:

   ```typescript
   import hre, { ethers, waffle } from "hardhat";
   import { expect } from "chai";
   import { IERC20 } from "@typechained";
   import { evm, wallet } from "./utils/index";
   import { BigNumber, Signer } from "ethers";

   // vitalik.eth: https://etherscan.io/address/0xd8da6bf26964af9d7eed9e03e53415d37aa96045
   const vitalik = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";
   // Dai address on mainnet: https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f
   const daiAddress = "0x6B175474E89094C44Da98b954EedeAC495271d0F";

   describe("DAI Mainnet Forking", () => {
     let dai: IERC20;
     const [alice] = waffle.provider.getWallets();
     let daiVitalik: Signer;
     let snapshotId: string;

     before(async () => {
       await evm.reset(hre);
       dai = (await ethers.getContractAt("IERC20", daiAddress)) as IERC20;
       daiVitalik = (await wallet.impersonate(vitalik)) as Signer;
       snapshotId = await evm.snapshot.take();
     });

     beforeEach(async () => {
       await evm.snapshot.revert(snapshotId);
     });

     describe("#transfer", () => {
       describe("with insufficient balance", () => {
         it("should revert", async () => {
           await expect(
             dai
               .connect(alice)
               .transfer(
                 wallet.generateRandomAddress(),
                 ethers.utils.parseEther("1")
               )
           ).to.be.revertedWith("Dai/insufficient-balance");
         });
       });

       describe("with sufficient balance", () => {
         let initSenderBalance: BigNumber;
         let initReceiverBalance: BigNumber;
         const amount = ethers.utils.parseEther("2");

         beforeEach(async () => {
           initSenderBalance = await dai.balanceOf(
             await daiVitalik.getAddress()
           );
           initReceiverBalance = await dai.balanceOf(alice.address);
           await dai.connect(daiVitalik).transfer(alice.address, amount);
         });

         it("sender balance should be deduced correctly", async () => {
           expect(
             await dai.balanceOf(await daiVitalik.getAddress())
           ).to.be.equal(initSenderBalance.sub(amount));
         });

         it("receiver balance should increase correctly", async () => {
           expect(await dai.balanceOf(alice.address)).to.be.equal(
             initReceiverBalance.add(amount)
           );
         });
       });
     });
   });
   ```

3. Finally run `yarn test` (do make sure that your `.env` has your `ALCHEMY_TOKEN` specified)
