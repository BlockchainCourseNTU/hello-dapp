# Building Smart Contract Project Boilerplate (Part 2)

⚠ make sure you already followed through [Part 1](./boilerplate.md), which setup a nice boilerplate with rich set of plugins installed, before moving on.️

While "part 1" has built up some basic "skeleton", this "part 2" will emphasize on introducing more "muscle" to our project such as essential list of `chai matchers` from `waffle`, and Mocking capabilities via `smock`.

Even though all tools introduced here are technically optional (you can already run away as "bag of bones"),
we would strongly recommend you to utilize these tools because they would accelerate your development especially when your contracts become more complex and harder to test comprehensively.

👍 We know these new tools and setups can be overwhelming, just so you know, you are already doing a great job! Keep up the effort and you are on your way to become a powerful smart contract developers!

## Testing with `waffle`

[`waffle`](https://ethereum-waffle.readthedocs.io/en/latest/index.html) is a testing library for smart contracts.
While it provides features from contract compilation to contract testing, we will mostly using 2 features from `waffle`:

- its sweet set of [`chai` matchers](https://ethereum-waffle.readthedocs.io/en/latest/matchers.html) for easy assertions.
- its [testing fixtures](https://ethereum-waffle.readthedocs.io/en/latest/fixtures.html) to save repetitive pre-state setup for tests to speed up execution.

Note that using `hardhat`'s own compilation, `ethers`'s contract factory deployment flow (explained later), and `typechain`'s contract types.
Astute readers might wonder an abstract question: "why could one compile using `hardhat`, but test with `waffle`?" -- the answer is the contract artifacts (under `build/artifacts`) generated by both tools are compatible.

Now let's setup our `hardhat` project with `waffle` (also check out [official doc](https://hardhat.org/guides/waffle-testing.html) if you want, or you could just follow our write-up).

> Since our "part 1" boilerplate is already built on a sample hardhat project which by default installed all dependencies of `waffle`, we can directly jump to writing tests. In case you missed it, you can install them with `yarn add -D @nomiclabs/hardhat-waffle ethereum-waffle chai @nomiclabs/hardhat-ethers ethers`.

1. To demonstrate a few of waffles' testing features, let's modify our `contracts/Greeter.sol`:

   ```solidity
   contract Greeter {
     // add a new event:
     event GreetingUpdated(string _new, address setter, uint256 amount);

     // update `setGreeting` as follows:
     function setGreeting(string memory _greeting) public payable {
       console.log("Changing greeting from", greeting, "to", _greeting);
       require(msg.value >= 1 ether, "minimal donation is 1 ether");
       greeting = _greeting;
       emit GreetingUpdated(_greeting, msg.sender, msg.value);
     }
   }

   ```

2. Jump to `test/greeter.spec.ts`, change it to the following:

   ```typescript
   import chai, { expect } from "chai";
   import { ethers, waffle } from "hardhat";
   import { Greeter } from "@typechained";
   const { solidity } = waffle;
   import GreeterABI from "../build/artifacts/contracts/Greeter.sol/Greeter.json";

   chai.use(solidity);

   describe("Greeter", () => {
     let greeter: Greeter;
     // this is the same list as `ethers.getSigners()`
     let [_, bob] = waffle.provider.getWallets();
     const initGreeting = "Hello, world!";

     const fixture = async () => {
       return (await waffle.deployContract(bob, GreeterABI, [
         initGreeting,
       ])) as Greeter;
     };

     beforeEach(async () => {
       greeter = await waffle.loadFixture(fixture);
     });

     it("Initalize with correct default greeting", async () => {
       expect(await greeter.greet()).to.equal(initGreeting);
     });

     describe("#setGreeting", () => {
       const newGreeting = "Bonjour!";

       it("should revert with insufficent donation", async () => {
         // this will send from alice (or first wallet) by default
         await expect(
           greeter.setGreeting(newGreeting, {
             value: ethers.utils.parseEther("0.9"),
           })
         ).to.be.reverted;
       });

       it("should update the greeting with sufficient donation", async () => {
         const donationInWei = ethers.utils.parseEther("2");
         // reconnect contract with a different signer before calling if you want to send from a different wallet.
         await expect(
           greeter.connect(bob).setGreeting(newGreeting, {
             value: donationInWei,
           })
         )
           // the following line is temporarily broken after London hardfork
           // .to.changeEtherBalances(greeter, [bob, greeter], [-donationInWei, donationInWei])
           .to.emit(greeter, "GreetingUpdated")
           .withArgs(newGreeting, bob.address, donationInWei);

         expect(await greeter.greet()).to.equal(newGreeting);
       });
     });
   });
   ```

   Then run `yarn test`, you should see all 3 tests passing.

Now, let's dive deeper into the test file.

- Since we are using `hardhat-waffle` plugin instead of a standalone `waffle` project, we use `import { waffle } from 'hardhat'` then `const { xxx } = waffle`, instead of directly from `import { xxx } from 'ethereum-waffle'`.
  Basically, the plugin re-export waffle with more integration setups through `hardhat.waffle` object, as explained [here](https://hardhat.org/guides/waffle-testing.html#adapting-the-tests).
- `chai.use(solidity)` enrich the default set of `chai matchers` (for general software) with a list of super helpful [contract-specific matchers](https://ethereum-waffle.readthedocs.io/en/latest/matchers.html).
  We will see a few example usages below.
- We use `waffle.provider.getWallets()` to get the list of wallets to deploy and send transactions later in the tests. The account list is the same as `ethers.getSigners()` result or `yarn hardhat accounts` output.
- Next we utilize the second important feature of `waffle` called [**fixtures**](https://ethereum-waffle.readthedocs.io/en/latest/fixtures.html). Please follow the link to read more. We usually use fixtures to avoid repetitive contract deployment for each test cases, instead we load from fixtures -- think of it as snapshot machine for contracts.
- For contracts deployment in tests, there are two ways:

  ```typescript
  import { Greeter } from "@typechained";
  import { ethers, waffle } from "hardhat";

  // either using `ethers`'s `ContractFactory`
  const factory = await ethers.getContractFactory("Greeter");
  const greeter = (await factory.deploy("my constructor param")) as Greeter;

  // or using `waffle`'s `deployContract`
  import GreeterABI from "../build/artifacts/contracts/Greeter.sol/Greeter.json";
  const greeter = (await waffle.deployContract(bob, GreeterABI, [
    "my constructor param",
  ])) as Greeter;
  ```

- As for the `mocha` test runner's execution order among nested `before()` and `beforeEach()`, please refer to [this StackOverflow question](https://stackoverflow.com/questions/21418580/what-is-the-difference-between-before-and-beforeeach#21419208)
- In the first test, we saw a standard `chai` matcher: `.to.equal()`.
- In the second test, we saw a matcher provided by `waffle.solidity` that we ask `chai.use(solidity)` before: [`.to.be.reverted`](https://ethereum-waffle.readthedocs.io/en/latest/matchers.html#revert).
- In the third test, we saw another matcher `to.emit().withArgs()` to test correct event emission. Note that you can "chain" assersions together like `expect().to.equal().to.emit()`.

🎉 Now you have basics of waffle testing under your belt!

## Mocking with `smock`
